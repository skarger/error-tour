Hello, I'm Stephen Karger, thanks for attending today.

I've wanted to to give this talk for awhile. The catalyst for it came all the way back at our company kickoff event in January.

People who were there will remember that in the morning we had the session for engineering and product,
and during Adam's presentation, one of his takeaway messages was that we should make sure to keep focus on quality during this coming year.
And he's been consistent about that, he said something similar at the 2019 kickoff event.

So at the time I was contemplating that a little, but simultaneously at work I was in flight on a project
and I was deciding how to approach a particular issue, and that issue is the topic of this talk, and I'll get to that in a minute.

First though I want to dig into quality. Really what is quality in software?
For this talk I've come up with a definition that I like. I'll say that software quality consists of three traits:

* One trait is if the software provides an ergonomic user interface.
    Does it look good, is it intuitive, does it make it easy to do what you need to do?
* The next trait is performance. If it's responsive and fast then it's higher quality than a slow version.
* And finally, the last core aspect of quality is does the software handle errors gracefully?
    Actually I'd say that error handling is a little underrated, it's often an afterthought in the development process,
    but it's absolutely fundamental to whether using the software is a good experience, whether it feels like quality.

So that's what this talk is all about. I'm going to give you a survey of different approaches to error handling,
and then I'm going to dive a little bit into what we have specifically with the tools we use at Salsify,
and I'll offer some recommendations about how to do error handling effectively.

And that's what I was looking at back in January. In my project I had identified that some runtime errors were
possible, there was no way to avoid that. I had to decide how to handle those errors. So I took that opportunity
to try to review best practices, and I started Googling, and as you might guess, I immediately found people
with strong opinions that completely contradicted each other.

So I wanted to explore it more.
As mundane as it sounds, the truth is that error handling is a hard problem, and we don't have all the answers yet.
Even in the course of preparing this talk, my own opinions evolved. I'll share that with all of you now.

Right then, so as I started outlining this talk, I was trying to think back about my own experiences as an end-user of software.
My first experience with a SaaS platform was my freshman year in college.

Blackboard story

Defining an errors is ambiguous

Understanding errors depends on real-world usage

Errors are common in software

First, we don't want errors to happen in the first place, and we have several techniques to that end.

But runtime errors do happen. When they do, our first goal is to convert them into non-errors.

Correctness and Robustness
    Examples

Robustness is preferable, but it doesn't always work. Sometimes our programs encounter conditions where they just can't fulfill their intended goal. What then?

Remainder of this talk is about dealing with these kinds error situations, where there is no correct way to continue the program.

In the days of C, error handling conventionally happened via return values.

While this worked, it was easy to forget to check return values.

Several languages emerged in the 80s and 90s that all included mechanisms for Exceptions.

General form of Exceptions are: Try running some code, if it fails, jump to this other code to deal with the error.

Exceptions introduce implicit control flow, like GOTO.

Catastrophic failures often happen due to incorrect exception handling.

More recent languages have gone back to communicating errors with return values, but with some twists.

Go and Rust both returned to the errors-as-data style.

Railway Oriented Programming provides a style for passing errors-as-data from function to function.

There are various factors to consider with errors-as-data vs. exceptions.

Most importantly, representing errors-as-data makes sense for errors that are part of the program's domain.

Another tradeoff to consider with errors-as-data is loose coupling.

Finally the practical consideration of are you working in a platform that has exceptions?
    Clojure -> data-oriented, functional, but interop with Java.
    Typescript -> type-checker supports static enforcement of Result types, but interop with JavaScript.

We have infrastructure for tracking exceptions (bugsnag).

Conversely, there are several criteria for when to use Exceptions.

Bugs (programming errors), exceptional cases that are outside the program domain.

HTTP requests are a subtle example of this. In some cases they are recoverable, but we will often want them to become exceptions.

JS Error objects have a name and a message, and a catch block can identify error type using the instanceof operator.

When a JS runtime error happens but it's not handled by any catch block, the browser will fire the window.onerror event. This can be configured to run a function as a last resort error handler.

try-catch works for async-await.

A try-catch block will not catch rejected promises. A promise must chain a catch call to handle the promise rejection.

When a promise rejects but there's no catch chained onto it, the browser will fire the unhandledrejection event. Like window.onerror, this can be configured as a last resort handler for rejected promises.

The basic way to configure Bugsnag is to set up handlers for window.onerror and unhandledrejection events that notify bugsnag of the error.

Ember.onerror abstracts over both of these.

Salsify's error-reporting library abstracts over Ember.onerror.

Ember routes can display an error template if an error occurs while loading the route's data.




