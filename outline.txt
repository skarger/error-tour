Hi everyone, I'm Stephen Karger, thank you for attending today.

OK, so I'll tell you what this talk is all about in a moment but I want start out with a bigger question.
When it comes to software, what is quality?
What does it actually mean for software to be high quality? And if you have built quality software, what did you do?
What details made it quality?

So I've come up with an answer that I like, which is that quality software has the following traits:

* Correctness. Now granted in the real-world we don't always have a clear single definition of the correct behavior.
    But still if you add 2 + 2 you want to get 4. Good quality software does the correct thing for well-defined problems.
* The next trait is if the software provides an ergonomic user interface.
    Does it look good, is it intuitive, does it make it easy to do what you need to do?
* Another trait is performance. If it's responsive and fast then it's higher quality.
* And finally, the last core aspect of quality is does the software handle errors gracefully?
    Errors happen, but then whether the software handles them well makes a huge difference in whether the software feels high quality.

So that last aspect is what this talk is about. I wanted to talk about error handling because in my experience,
it tends to be something of an afterthought. We tackle it when we need to, case-by-case.
It's actually rare to have shared clear understanding of here's how this application deals with errors.

But that's surprising because for one thing the programming languages we use do provide the basic tools, and second we have plenty of evidence
that our programs are going to encounter errors. It's a known problem to be solved. And it's somewhat low-hanging fruit,
it's very doable to make a big step towards great quality just by planning out error handling approach a little bit.

So I wanted to dig into this topic, and land on some actionable techniques
for how to handle errors at the level of an application.

I'm going tour through different approaches to error handling, and put the tools we have in Ruby and JavaScript
in context, and talk about tradeoffs.

I'm going to touch on Salsify-specific error handling tools we have available already,
and finally share the overall design recommendations that I've landed on myself.

So a couple months ago I tried to go to Jenkins and I saw this page. Stack trace.
Jenkins is a tool for programmers, and as programmers when we talk about errors it's easy to think about this. An Exception.

But I want to show you this next example. Here is the Enhanced Content UI in Salsify. I've opened this publish dropdown and it's showing me
a collection of retailers where I can send my Enhanced Content.
But in the next slide, this is a real bug that we had. I click the Publish dropdown, and I just see this empty box.

Let me call out that this bug was never reported. I only found it while investigating something I'd
seen in Bugsnag a few times.

If I open the developer tools I can see that the network request returned a 503, and that's why it couldn't populate the list of retailers.

But imagine the end-user's experience here. They see this empty box.
It's confusing, it's not truly evident that an error occurred. A user might think they missed some setup or configuration.

Another example on this next slide, I've just updated my Enhanced Content layout to reference an Image property.
But if I open dev tools I can see that when I set that value, the client tried to save the layout, but the API returned a 500 error.
So even though the UI looks fine, if I reload the page I'd see that my layout has not saved my work.

What I'm getting at is that for end users the experience of errors is not 1-to-1 with exceptions. Very frequently it's more subtle.
The software is behaving in a way that seems off, but it's quiet, and it's hard to understand cause and effect, and
that ultimately leads to lower trust in the software, and a feeling of lower quality.

According to me then, the first principle behind error design is communication. A good error design needs to answer:
how do we inform end users,
how do we inform customer support,
how do we inform PMs,
and of course how do we inform ourselves?

Honestly this is the most important message. Devising a communication plan
for when errors happen is the core step to dealing with errors in a good quality way.

OK, so when it comes to software errors, what do we want?

Well we don't want them to happen in the first place! Clearly, preventing errors is preferable to dealing with them at runtime.

And we employ several techniques to try to prevent errors. Testing, type checking, and code review are all helpful
for preventing errors, among other nice outcomes.

But we all know our software still has errors in production. And a big part of our jobs as engineers
is to convert runtime errors into non-errors. A common example is the program is trying to work with a data value
that it expects to be non-null, but then it's null and the program throws an error. So then we edit the code
to make that a non-issue, either by adding a condition to check for nulls, or telling the user to supply
a different value, or converting the null value into a valid default. And this process of widening the range
of states that the program can handle, so that errors become non-errors, is an important part of our day-to-day work.


I want to point out that these techniques I've just mentioned are before-the-fact and after-the-fact.
They are steps we take to prevent runtime errors from occurring in the first place, and to react to runtime errors that
have already happened. When we apply these techniques we're using knowledge that we already have.

But importantly, there's also category of errors that we don't know about yet. We have code paths where an error
can happen in certain cases, but we're simply not aware of that right now, at least we don't know it in any practical way.
So another guiding idea here is that error handling design needs to confront uncertainty.
When we think about how to handle runtime errors, we need to figure out how to deal with situations
that we don't necessarily have concrete knowledge about now.

So in the remainder of this talk I'm going to be talking about code, but I hope you'll keep these main ideas
in mind, that good error handling design takes a holistic view of user experience and that it concerns situations
that our code cannot fully anticipate.

Now I want to briefly talk about history.

In the C language, error handling conventionally happened via return values.

In this example C program we're making a system call to open a file, and that returns a file pointer.
Then we're trying to write to the file using that file pointer.

But the file doesn't exist. Writing to that non-existent file results in a segfault and the program is killed by the operating system.

So in the next slide I've fixed that bug.
If the returned file point is NULL, that opening the file failed.
So I have logic here to check for a NULL return value, and avoid writing to the file in that case,
and the program continues without crashing.

This works. But as a C programmer you don't have to check return values. And failing to check return values for errors
turns out to be a very common cause of bugs, and those bugs can be very confusing, because they will often
manifest somewhere downstream of the original problem and cause the program to suddenly crash, or write corrupt data,
or even have a security vulnerability.

So then there was a stretch in the 80s and 90s where some new languages came out that
became mainstream in commercial software development.
These languages here all brought a concept of Exceptions.

Starting with this Java example, I'm trying to parse a string into an integer. It works for the string 1000 but then
throws an exception for A grand. And this shows the general form of Exceptions:
Try running some code, if it fails, jump to this other code to deal with the error.

Next we see an example in Ruby, same exact concept, just using the words begin rescue ensure
instead of try catch finally.

And then we have a JavaScript example. An interesting point here is that JS has a built-in function
to parse an integer from a string, but instead of throwing an exception it returns the value NaN. So I had to
check for NaN and then explicitly throw an exception. But still, unlike C, JavaScript does support this same
try catch finally construct with the error conveyed as an Exception.

So Exceptions were a way of preventing the problem in C where the programmer forgets to check return values, because
Exceptions forcibly re-route the code execution. But even though that's helpful it has a dark side. It's like walking
on a minefield, any function call can blow up.
And as a result it introduces implicit control flow, sort of like a GOTO statement. This can make program logic hard to reason about,
because when you are reading the exception handling code, it's not always obvious what the context is, i.e. what
are all the circumstances where we'd be running this code and what details do we need to clean up?

And in fact, here is a formal study that analyzed bug reports from several big open source projects and found that 92% of
catastrophic failures had happened due to incorrect exception handling. So a clear actionable step here is
make sure to test exception handling code.

But there are software engineers who just view the problems with Exceptions as making them a straight up undesirable tool.
Some more recent languages that have become mainstream decided not to have exceptions at all. They went back to
communicating errors with return values, like C, just with some twists.

In Go, the big change compared to C is that functions return two distinct values, with the error value in the second position,
so return values and errors are not overloaded. And ergonomically this is much better. But it's also worth noting
that you are still free to ignore the error value.

In Rust, they took the approach with functions that can fail where they wrap the return value in a Result type.
So a Result data type has two variants, Ok or Err, and the Rust type checker forces you to cover those possibilities.
So Rust doesn't have Exceptions, but it still prevents you from forgetting to handle errors.

This style of wrapping a return value in Result type supports a functional style of programming, because instead of
and exception side effect, you're just passing data in and getting data out.
I'll show an example of that here. On this slide there are these three functions, parse_number, ensure_positive, and double.
The first two functions return a Result type.

So then in the next slide I have a program that uses these functions. It calls the two_track_computation function,
and then two_track_computation starts out by calling parse_number, and the Result value flows into map_err which
transforms the Result into another Result, and then it flows into the ensure_positive function, then it tries to
double the result, and finally it produces a message depending on whether the Result is Ok or an Error.

It's not important to understand all the details of Rust here, what's important is to see this pattern that the
data is flowing in a linear way from function to function, with errors conveyed inside these Result values.
There are no Exceptions that cause the control flow to jump.

And this style is not unique to Rust, in 2014 an F# programmer named Scott Wlaschin wrote a blog post calling this style Railway Oriented Programming.
It's this provides style where data is flowing through your program like it's on a railroad track, and as long as it's
successful it keeps rolling along that success track, but if it encounters and error it switches to the error track.
So you can string together a functional pipeline of this way. And sometimes this is a lot clearer to follow than if you had exceptions.

So Ruby and JavaScript do have exceptions, but in these languages you can still code in a Railway Oriented style.
And if you use Sorbet or TypeScript you can enforce that you handle the variants.

But there are some issues to consider about that. And I'm going to mention a few of them.

Most importantly, representing errors-as-data makes sense for errors that are part of the program's domain.
That's really another way of understanding the common rule of thumb people give that exceptions should be exceptional.
Exceptions should only be used for situations that are outside the expected cases this program is meant to support.
But if the error in question is actually a well-defined part of the domain, then modeling it as a data value is helpful.
An example of that which comes up a lot at Salsify is when we model the lifecycle of some entity using a database row with
a status column, and we want to record failures and display them to the end user. It also comes up when we're processing
a collection, and we know that it may fail for some items, but we do want to support that kind of best-effort partial success.

Then another tradeoff to consider with errors-as-data is loose coupling.
When a web API needs to return an error, how do we do it?
In the API situation we need to put the error on the wire.
We need to transmit it to a different computer running a different program, often written in a different programming language.
So we send the error as data, sometimes just an HTTP response with status code 500 or 404,
or a JSON payload with an errors field.

And when we have two programs communicating remotely, there's this natural imperative to make them work with looser coupling.
That's even one of the de facto motivations for microservices, forcing yourself to impose loose coupling.

But even inside one program it may be useful to apply the lesson from web APIs,
and pass pure data around in our program to promote modularity.
If we want to have a clear boundary in our program, we can just ask: will this work if I only use data between these two parts?
If I were to extract these two into separate programs, would it work to communicate over a web API or a message queue?
Including signaling error situations?
So if it's desirable for that answer to be use then communicating errors-as-data between those sub-systems of the program.

Another practical tradeoff between exceptions and errors-as-data is are you working in a platform that has exceptions?
So Clojure is a functional language that puts heavy emphasis on data-orientation, but it's also designed to have seamless interop with Java.

And with TypeScript, we can use the type-checker to support static enforcement of Result types in a similar style to Rust, but TypeScript
is of course meant to interop with JavaScript.

OK so Java and JavaScript both throw exceptions, so realistically in these languages you need to deal with exceptions anyway,
and sometimes that's going to push the decision to favor exceptions for the error handling approach.

Lastly a very good reason to use exceptions is that it's a way to make them visible to us.
With exceptions, we have infrastructure to report them to Bugsnag.

That's important because a key challenge for us as developers is that errors are hard to see.
They're usually low-frequency events, and they often only come out with real-world usage.
That makes us discount their importance.

Sometimes as developers we'll realize there's a potential for an error, but it's going to take
more work to address it, and we just say that's an "edge case".

But calling something an edge case is like a geometric idea. You have this square representing all the cases,
and most of the cases are the yellow in the middle there, but there's a thin edge of cases around the outside
that we're not covering well.

But you need error reporting to understand the size of the edge.

Is it more like this? And really we ought to deal with it.

In a previous job we had a situation where most of the time it looked like this, but on the
two days of the year when the times changed for daylight savings time, the edge was like this.
And it was a disaster. But then we'd forget about it.

So you really need records of the errors in order to prioritize, and reporting exceptions
to Bugsnag is a pragmatic way to accomplish that.

OK for the last portion of this talk I want to get into some more Salsify-specific
details. Starting out on the backend, we do already have some error handling support
in our shared libraries. Here's a snippet from the SalsifyGraphQL ruby gem.
It will catch errors and this use our ExceptionReporter
gem to send the error to Bugsnag, and then translate the error into an API response
following GraphQL conventions for an error payload.
(pause to look at code)

For background jobs, Salsify has an extension to Delayed Job that has a similar approach
of catching errors and reporting them to Bugsnag.
(pause to look at code)

So if you're using these libraries than you automatically have this basic error handling framework,
which is great. But is it enough?

What I think is that this is a great default, but at the level of an individual application,
we have have more specific information, so we can do more. Inside an application, we can
layer in our own handling so instead of just saying "report the error," we can tailor
the approach to the specific action the user wanted to do that failed.

Again, attaining high quality error handling means thinking holistically. A backend error strategy
like this is a start. But once we translate the error into an API response payload,
or for a background job, once we update a database row to record that this action failed, then what?
The backend can't be the end of the story. We need to one more step to
communicate the error to the end user, or whoever else ought to know.

Making that final step, connecting the dots on the client side, really improves quality a lot.
And there's a fairly straightforward effort to make, where it's like we have a checklist.
Each time we add a new API request to the client, or each time we implement a new background job,
one of the questions is what do we display when it fails? What information does the
client need to obtain from the server to support that display?
It's definitely more than zero additional effort, but not much more, to go a long way.

Of course a way to make it easier is to not even devise a customized error display for each
server interaction, but just decide on a generic way to render failed API requests
and a generic way to show a list of failed background jobs. Those
kinds of generic solutions won't always be as good UX as if you tailored it specifically,
but still so much better than nothing.

Let me point out, for API requests, we already do have something a little bit like that
in the main Salsify client app in dandelion.

There's a generic handler for when an Ember route tries to load data from
the API, but the API request returns an error status like a 404 or 500.
The client will flash an error message in a yellow bar near the top of the screen.
So this at least provides feedback to the end-user that something went wrong.

But let me show you a real example.
In this video you'll see I'm looking at my list of Enhanced Content layouts.
This screen comes from the Enhanced Content Ember engine.

Then you'll see I'm going click the pencil button on the right to edit a layout.
But under the hood, the API request to load that layout is going to fail.
And then you'll see I click a few times trying to figure out what's going on,
and finally I give up and go back to the products index page.

Let's watch...

So click, nothing happens, no feedback, I click again, then I give up and go to Products.

Then randomly I see the yellow error bar on the products index.
So yes Salsify has this standard UI feedback for failed API requests, but it's really not that clear.

Now the cause of this one is tricky, it's a combination of the CSS we're using for
the Enhanced Content layout list interacting with the way that yellow error message bar works in dandelion.
On one hand you could blame the EC engine for this because the way it's creating the UI obscures the error bar.
But I hope you can see that when we're working on an engine like this, it's pretty difficult to understand
the edge cases of how it will interact with dandelion. And point of fact, this problem has existed in
enhanced content for a year, and we never knew about it until I prepared this tech talk.
It's a low frequency event that's difficult to discover in dev.

This is a place where the microfrontends project should help, because hopefully a micro-app will
be able to manage it's full UI, including error display, so we should be able to pull off this
holistic error handling more easily.

In any case, architecturally, I want to call out the tactic that SalsifyGraphQL and DelayedJob extensions
are taking, where they handle error at the boundaries. It's at the entrypoints to the program,
where an API request comes in, or at the top-level of executing a background job. These are
natural places to build error handling foundations because they're often the starting point for some
business domain action, which helps clarify how communicate to the end user.

Other examples
of boundaries on the backend are when we try to save to the database, or when we make an HTTP request
to another service. These boundary points are  prone to errors and also


But on the client, at a first approximation, we can adopt the same concept of handling errors
at the boundaries. An API response is one of a few natural entry-points to the frontend program.

But there are some pragmatic issues to deal with that I'll go into now.


When a JS runtime error happens but it's not handled by any catch block,
the browser will fire the window.onerror event.
This can be configured to run a function as a last resort error handler.
When a promise rejects but there's no catch chained onto it, the browser will fire the unhandledrejection event. Like window.onerror, this can be configured as a last resort handler for rejected promises.




Ember provides a function, Ember.onerror, that's meant as a backstop for unhandled errors.
Salsify's error-reporting library abstracts over Ember.onerror.
Ultimately, the error-reporting library configures reporting to Bugsnag.
That happens once in Dandelion. That one-time setup then applies to our mounted engines.

But there are issues with this. Let me walk through some examples.



Then also, in the client, making requests to the API is not the only thing that can fail.
We can have errors in the JavaScript code itself, for example in the logic of an Ember component.

So I want to look at another example. Here we're looking at the list of layouts again.

Notice the rows of the table.
They're Ember components. So we have a component representing the table row,
and then inside that we have a component that displays what retailers you've published this layout to,
and another component that shows the status of the layout,
and finally on the far right there's action icons to edit the layout, duplicate, or delete it.

So imagine that that "Most Recent Status" component throws an exception, what's going to happen?
Well the overall layout table still renders, but because the status component errored, everything
after that is gone. You can see there's no status, but also the action buttons aren't visible, and the
table alignment is off. So for end-users the error is subtle.

But, since we have Ember.onerror configured, we should hope at least report the error to Bugsnag right?
So we as developers can at least find out about it and hopefully fix the problem.

Well I'm sorry to say now, it turns out that's not guaranteed either. While I was prepping this
talk I discovered that there are some issues with Ember.onerror where
it doesn't actually capture all unhandled errors. For example in my tests an exception
raised by a component action doesn't make it to Ember.onerror. So then I was looking into
this and I found some other Github issues of where other errors don't make it to Ember.onerror.

And interestingly I found this comment where Robert Jackson says that Ember should probably
stop advising people to use Ember.onerror, in favor of the native window.onerror and unhandledexception.

We need to get to microfrontends.





Ember routes can display an error template if an error occurs while loading the route's data.




