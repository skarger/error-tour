Intro
  Why?
    Needed to handle fetch errors.
    Blackboard story.
        Is a timeout a bug?
        Who's fault?

  What is quality?
    Handling errors
    Performance
    UI

  What are errors?

  Computer programs have inputs, outputs, side effects, and internal logic.

    Inputs:
        stdin
        OS signals (SIGHUP, SIGTERM)
        inbound network requests
        DB query results

    Outputs / Side effects:
        stdout, stderr
        graphical rendering
        writing data to DB, network socket, file system

    Internal logic:
        Data transformation
        Calculation
        Business rules


  Errors often happen on all.
    Unexpected inputs
    Problems with side effects - DB queries, DB writes, HTTP requests
    Internal logic with unexpected data flow (e.g. null)
    Exceptional environmental conditions: out of memory, disk failure, incorrect configuration

    Question: are all these errors basically the same kind of thing?
        Hint: No.

What do we want as far as errors?

    1. Errors don't happen!
        In other words, we want that the software works gracefully with a wide range of real-world circumstances.

    2. When errors do happen, we
        * Provide information to users.
        * Notify engineers/managers/PM/CS that something went wrong.
        * Are able to rectify any ongoing problems.

Is this the status quo? Have we accomplished this already?
    Sort of. We do a decent job with errors, but it's not rock solid. Un-inflated grade: B-

    So why is that? What brought us to this point, and what would we need to change to do better?

History
    C style error handling. No exceptions.

    $ gcc -Wall no-exceptions.c

    $ ./a.out
    1. Testing return value from malloc...
    4 bytes successfully allocated and set:
    p1[0] == 0
    p1[1] == 1
    p1[2] == 4
    p1[3] == 9

    macOS C library writes malloc error output to stderr:
    a.out(41438,0x7fffb6bc8380) malloc: *** mach_vm_map(size=150000000000000) failed (error code=3)
    *** error: can't allocate region
    *** set a breakpoint in malloc_error_break to debug

    But program keeps running, the above is not an exception!

    Could not allocate 150000000000000 bytes.


    2. Testing errno after trying to open file...
    Value of errno: 2
    Error printed by perror: No such file or directory
    Error opening file: No such file or directory

    Again, no exception raised when opening non-existent file, program still running.
    Have a nice day.


    Aside from error handling, C has a variety of other limitations, and people were motivated to create programming languages that improved upon it.

    C: 1972

    C++: 1985

    Python: 1990

    Ruby: 1995
    Java: 1995
    JavaScript: 1995
    PHP: 1995 * included try/catch, but originally not exceptions.

    C#: 2000

    Surely these weren't the only languages created in that era, but they've had a lot of influence
    on modern web and enterprise development,
    and one major difference from C they share is the notion of exceptions.

Exceptions
    See examples. A lot of research about exceptions analyzes Java, so it's shown here, but as we can see Ruby and JS are similar.

    General idea: run some code. If something goes wrong, stop execution, go run some other code.
    This happens without the programmer checking whether something went wrong.
    This construction also has the finally/ensure block to run some "resolution" code in all cases.
