Intro
  Why?
    Needed to handle fetch errors.
    Blackboard story.
        Is a timeout a bug?
        Who's fault?

  What is quality?
    Handling errors
    Performance
    UI

  What are errors?

  Computer programs have inputs, outputs, side effects, and internal logic.

    Inputs:
        stdin
        OS signals (SIGHUP, SIGTERM)
        inbound network requests
        DB query results

    Outputs / Side effects:
        stdout, stderr
        graphical rendering
        writing data to DB, network socket, file system

    Internal logic:
        Data transformation
        Calculation
        Business rules


  Errors often happen on all.
    Unexpected inputs
    Problems with side effects - DB queries, DB writes, HTTP requests
    Internal logic with unexpected data flow (e.g. null)
    Exceptional environmental conditions: out of memory, disk failure, incorrect configuration

    Question: are all these errors basically the same kind of thing?
        Hint: No.

What do we want as far as errors?

    1. Errors don't happen!
        In other words, we want that the software works gracefully with a wide range of real-world circumstances.

    2. When errors do happen, we
        * Provide information to users.
        * Notify engineers/managers/PM/CS that something went wrong.
        * Are able to rectify any ongoing problems.

Is this the status quo? Have we accomplished this already?
    Sort of. We do a decent job with errors, but it's not rock solid. Un-inflated grade: B-

    So why is that? What brought us to this point, and what would we need to change to do better?

History
    C style error handling. No exceptions. Return value, errno.

    Aside from error handling, C has a variety of other limitations, and people were motivated to create programming languages that improved upon it.

    C: 1972

    C++: 1985

    Python: 1990

    Ruby: 1995
    Java: 1995
    JavaScript: 1995
    PHP: 1995 * included try/catch, but originally not exceptions.

    C#: 2000

    Surely these weren't the only languages created in that era, but they've had a lot of influence
    on modern web and enterprise development,
    and one major difference from C they share is the notion of exceptions.

Exceptions
    See examples. A lot of research about exceptions analyzes Java, so it's shown here, but as we can see Ruby and JS are similar.

    General idea: run some code. If something goes wrong, stop execution, go run some other code.
    This happens without the programmer checking whether something went wrong.
    This construction also has the finally/ensure block to run some "resolution" code in all cases.

Ruby exceptions: details
    RuntimeError
    Do not rescue Exception
    Errno (RestClient example)
    Rails
    salsify_grape
        https://github.com/salsify/salsify_grape/blob/master/lib/salsify_grape/base_api.rb#L41
    salsify_graphql-server
        https://github.com/salsify/salsify_graphql-server/blob/master/lib/salsify_graphql/server/base_controller.rb
    DelayedJob
        https://github.com/collectiveidea/delayed_job#hooks
        https://github.com/salsify/delayed-job-extensions/blob/master/lib/delayed/extensions/worker_exception_handling.rb
        https://github.com/salsify/delayed-job-extensions/blob/master/lib/delayed/extensions/exception_reporter_plugin.rb




JS exceptions: details

Problems with exceptions

Modern alternatives: Result Type
